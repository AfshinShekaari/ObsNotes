/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  H1ObsidianPluginSettingTab: () => H1ObsidianPluginSettingTab,
  default: () => H1ObsidianPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  h1Username: "",
  h1Token: "",
  directory: "Bug Bounty"
};
var H1ObsidianPluginSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const {
      containerEl
    } = this;
    containerEl.empty();
    containerEl.createEl("h2", {
      text: "HackerOne Plugin Settings"
    });
    new import_obsidian.Setting(containerEl).setName("HackerOne Username").setDesc("Enter your HackerOne username").addText(
      (text) => text.setPlaceholder("Enter your username...").setValue(this.plugin.settings.h1Username).onChange(async (value) => {
        this.plugin.settings.h1Username = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("HackerOne Token").setDesc("Enter your HackerOne API token").addText(
      (text) => text.setPlaceholder("Enter your token...").setValue(this.plugin.settings.h1Token).onChange(async (value) => {
        this.plugin.settings.h1Token = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("path").setDesc("Enter the path of the bug bounty folder").addText(
      (text) => text.setPlaceholder("./Bug Bounty").setValue(this.plugin.settings.directory).onChange(async (value) => {
        this.plugin.settings.directory = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
var contentBugSummaryAlltime = '# Bugs \n```dataview\nTABLE program,state,bounty,severity,url,created_at\nWHERE Type="bug-bounty-vuln"\nSORT created_at DESC\n```\n# Total \n```dataview\nTABLE sum(rows.bounty) as TotalBounty\nWHERE Type="bug-bounty-vuln" \nWhere bounty > 0\nGROUP BY TotalBounty\n```\n# Best Programs\n```dataview\nTABLE  sum(rows.bounty) as TotalBounty\nWHERE type="bug-bounty-vuln"and bounty > 0\nGROUP BY program\nSORT sum(rows.bounty) DESC\n``` \n\n';
var contentBugSummaryCurrentYear = "# " + new Date().getFullYear() + ' bug reports\n\n# Bugs\n```dataview\nTABLE program,state,bounty,severity,url,created_at\nWHERE Type="bug-bounty-vuln" and contains(dateformat(created_at,"yyyy"),"' + new Date().getFullYear() + '")\nSORT created_at DESC\n```\n# Total \n```dataview\nTABLE sum(rows.bounty) as TotalBounty\nWHERE Type="bug-bounty-vuln" \nWhere bounty > 0 and contains(dateformat(bounty_awarded_at,"yyyy"),"' + new Date().getFullYear() + '") \nGROUP BY TotalBounty\n```\n# Best Programs \n```dataview\nTABLE  sum(rows.bounty) as TotalBounty\nWHERE type="bug-bounty-vuln" and contains(dateformat(created_at,"yyyy"),"' + new Date().getFullYear() + '")  and bounty > 0\nGROUP BY program\nSORT sum(rows.bounty) DESC\n``` \n\n';
var H1ObsidianPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new H1ObsidianPluginSettingTab(this.app, this));
    try {
      await this.app.vault.create(`${this.settings.directory}/bugs-summary-all-time.md`, contentBugSummaryAlltime);
    } catch (error) {
      new import_obsidian.Notice("Error creating summary file:", error);
    }
    try {
      await this.app.vault.create(`${this.settings.directory}/bugs-summary-current-year.md`, contentBugSummaryCurrentYear);
    } catch (error) {
      new import_obsidian.Notice("Error creating summary file:", error);
    }
    this.addCommand({
      id: "fetch-h1-reports",
      name: "fetch HackerOne Reports",
      callback: () => this.fetchH1Reports()
    });
  }
  async overwriteFile(fileName, fileContent) {
    let file = this.app.vault.getAbstractFileByPath(fileName);
    if (file) {
      await this.app.vault.delete(file);
    }
    try {
      const newFile = await this.app.vault.create(fileName, fileContent);
    } catch (err) {
      new import_obsidian.Notice("Error: Unable to overwrite the file:" + err);
      console.log("Error overwriting file:", err);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async fetchH1Reports() {
    if (this.settings.h1Username == "") {
      new import_obsidian.Notice("You need to fill your hackerone username in the settings of the plugin");
      return;
    }
    if (this.settings.h1Token == "") {
      new import_obsidian.Notice("You need to fill your hackerone API Token in the settings of the plugin");
      return;
    }
    let h1Earnings = [];
    let h1Reports = [];
    new import_obsidian.Notice("Fetching your HackerOne reports...");
    try {
      h1Reports = await this.getH1Reports();
      h1Earnings = await this.getH1Earnings();
    } catch (error) {
      new import_obsidian.Notice("Error fetching HackerOne reports: " + error.message);
    }
    try {
      await this.createNotes(h1Reports, h1Earnings);
    } catch (error) {
      new import_obsidian.Notice("Error creating notes: " + error.message);
    }
  }
  async createNotes(h1Reports, earnings) {
    const vault = this.app.vault;
    const folderPath = `${this.settings.directory}/Bugs`;
    try {
      await vault.createFolder(folderPath);
    } catch (error) {
      console.log("Error creating folder: " + error.message);
    }
    for (const item of h1Reports) {
      try {
        var severity = item.relationships.severity.data.attributes.rating;
      } catch (error) {
        severity = "undefined";
      }
      try {
        var program = item.relationships.program.data.attributes.handle;
      } catch (error) {
        program = "undefined";
      }
      const specialChars = /([\'\[\]\/])/g;
      const title = item.attributes.title.replace(":", "").replace(specialChars, "\\$1");
      const noteContent = "---\nType: bug-bounty-vuln\ntitle: " + title + "\nurl: https://hackerone.com/reports/" + item.id + "\n" + await this.serializeAttributes(item.attributes) + "bounty: " + await this.getBountyReport(item.id, earnings) + "\nseverity: " + severity + "\nprogram: " + program + "\n---\n" + item.attributes.vulnerability_information.replace("<%", "<");
      var fileName = `${folderPath}/${item.attributes.title.replace(/[^a-z0-9_ -]/gi, "_")}-${item.id}.md`;
      console.log(`Create bugs ${item.attributes.title}.`);
      await this.overwriteFile(fileName, noteContent);
    }
    new import_obsidian.Notice("Bugs has been updated successfully.");
  }
  async getBountyReport(reportId, earnings) {
    let ret = 0;
    for (const earning of earnings) {
      if (earning.type === "earning-bounty-earned") {
        if (earning.relationships.bounty.data.relationships.report.data.id === reportId) {
          ret += parseInt(earning.attributes.amount);
          if (earning.attributes.bonus_amount !== void 0) {
            ret += parseInt(earning.attributes.bonus_amount);
          }
        }
      } else if (earning.type === "earning-retest-completed") {
        if (earning.relationships.report_retest_user.data.relationships.report_retest.data.relationships.report.data.id === reportId) {
          ret += 50;
        }
      } else {
        new import_obsidian.Notice(earning.type);
      }
    }
    return ret;
  }
  async serializeAttributes(attributes) {
    let yamlString = "";
    for (const key in attributes) {
      if (key != "vulnerability_information" && key != "title") {
        let content = attributes[key];
        yamlString += `${key}: ${content}
`;
      }
    }
    return yamlString;
  }
  async getH1Reports() {
    const authString = btoa(`${this.settings.h1Username}:${this.settings.h1Token}`);
    let page = 0;
    let h1ReportsRet = [];
    while (true) {
      page += 1;
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://api.hackerone.com/v1/hackers/me/reports?page[size]=100&page[number]=${page}`,
        method: "GET",
        headers: {
          Authorization: `Basic ${authString}`,
          Accept: "application/json"
        }
      });
      if (response.status != 200) {
        new import_obsidian.Notice("Error fetching hackerone api");
        new import_obsidian.Notice("Error fetching hackerone api");
      }
      if (response.json.data.length == 0) {
        return h1ReportsRet;
      }
      h1ReportsRet = h1ReportsRet.concat(response.json.data);
    }
  }
  async getH1Earnings() {
    const authString = btoa(`${this.settings.h1Username}:${this.settings.h1Token}`);
    let page = 0;
    let earnings = [];
    while (true) {
      page += 1;
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://api.hackerone.com/v1/hackers/payments/earnings?page[size]=100&page[number]=${page}`,
        method: "GET",
        headers: {
          Authorization: `Basic ${authString}`,
          Accept: "application/json"
        }
      });
      if (response.status != 200) {
        new import_obsidian.Notice("Error fetching hackerone api");
      }
      if (response.json.data.length == 0) {
        return earnings;
      }
      earnings = earnings.concat(response.json.data);
    }
  }
};
